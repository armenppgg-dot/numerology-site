<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Котёнок: Полоса испытаний</title>
  <style>
    :root {
      --bg-1: #86d8ff;
      --bg-2: #5a83ff;
      --panel: rgba(23, 38, 84, 0.84);
      --panel-line: rgba(255, 255, 255, 0.2);
      --text: #f7fbff;
      --accent: #ffd24d;
      --pink: #ff6faf;
      --good: #7bff9d;
      --danger: #ff6b86;
      --shadow: rgba(6, 20, 60, 0.35);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at 50% 0%, #b2f0ff 0%, #79b0ff 45%, #5a73d8 100%);
      font-family: "Trebuchet MS", "Segoe UI", system-ui, sans-serif;
      color: var(--text);
      padding: 12px;
    }

    .game-shell {
      width: min(100%, 960px);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.05));
      border: 2px solid rgba(255, 255, 255, 0.45);
      border-radius: 22px;
      box-shadow: 0 24px 46px var(--shadow);
      backdrop-filter: blur(5px);
      overflow: hidden;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--panel);
      border-bottom: 1px solid var(--panel-line);
      flex-wrap: wrap;
    }

    .stats {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      font-weight: 700;
      font-size: clamp(12px, 2.8vw, 15px);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.3);
    }

    .progress-wrap {
      width: min(260px, 56vw);
      height: 14px;
      background: rgba(0, 0, 0, 0.25);
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      overflow: hidden;
      position: relative;
    }

    #progressBar {
      width: 0;
      height: 100%;
      background: linear-gradient(90deg, #ffe072, #ff9c4f);
      box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.5);
      transition: width 0.1s linear;
    }

    .sound-btn {
      border: 0;
      border-radius: 10px;
      background: linear-gradient(160deg, #6ef6b7, #57c5ff);
      color: #08233f;
      font-weight: 800;
      padding: 8px 12px;
      cursor: pointer;
      min-width: 92px;
    }

    .stage {
      position: relative;
      aspect-ratio: 16 / 9;
      min-height: 280px;
      max-height: 66vh;
      background: linear-gradient(180deg, var(--bg-1) 0%, var(--bg-2) 70%, #537f4a 70%, #6aa359 100%);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(11, 23, 56, 0.62), rgba(12, 20, 50, 0.92));
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      z-index: 20;
    }

    .overlay[hidden] { display: none; }

    .panel {
      max-width: min(90vw, 560px);
      background: rgba(16, 32, 78, 0.86);
      border: 2px solid rgba(255, 255, 255, 0.34);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 16px 38px rgba(0, 0, 0, 0.35);
    }

    .title {
      margin: 0 0 12px;
      font-size: clamp(26px, 5.4vw, 40px);
    }

    .desc {
      margin: 0 0 18px;
      line-height: 1.5;
      font-size: clamp(14px, 2.8vw, 17px);
    }

    .main-btn {
      border: 0;
      border-radius: 13px;
      padding: 12px 22px;
      font-size: clamp(16px, 3vw, 20px);
      font-weight: 800;
      cursor: pointer;
      background: linear-gradient(140deg, #ffe97f, #ffa54f);
      color: #3b1900;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      padding: max(10px, env(safe-area-inset-bottom)) 12px 12px;
      background: rgba(13, 22, 56, 0.92);
      border-top: 2px solid rgba(255, 255, 255, 0.16);
    }

    .control-btn {
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 14px;
      padding: 13px 8px;
      color: #f0f8ff;
      background: linear-gradient(180deg, #2f56b6, #223c84);
      font-size: clamp(14px, 2.8vw, 18px);
      font-weight: 800;
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .control-btn:active,
    .control-btn.active {
      background: linear-gradient(180deg, #5477dd, #2c4ca8);
      transform: translateY(1px);
    }

    @media (max-width: 640px) {
      body { padding: 0; }
      .game-shell {
        width: 100%;
        border-radius: 0;
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr auto;
      }

      .stage {
        max-height: none;
        min-height: 0;
      }

      .panel { padding: 14px; }
    }
  </style>
</head>
<body>
  <div class="game-shell">
    <header class="hud">
      <div class="stats">
        <span>Жизни: <strong id="lives">4</strong></span>
        <span>Контрольная точка: <strong id="checkpoint">Старт</strong></span>
      </div>
      <div class="progress-wrap" aria-label="Прогресс до финиша"><div id="progressBar"></div></div>
      <button id="soundBtn" class="sound-btn" type="button">Звук: вкл</button>
    </header>

    <div class="stage">
      <canvas id="gameCanvas" width="1280" height="720" aria-label="Мини-игра про котёнка"></canvas>

      <div class="overlay" id="startOverlay">
        <div class="panel">
          <h1 class="title">Котёнок на полосе испытаний</h1>
          <p class="desc">Беги к финишу через батуты, платформы, маятники и другие испытания. Кнопки снизу: Влево, Вправо, Прыжок, Вниз. На клавиатуре: ← →, Space/↑, ↓.</p>
          <button id="startBtn" class="main-btn" type="button">Старт</button>
        </div>
      </div>

      <div class="overlay" id="winOverlay" hidden>
        <div class="panel">
          <h2 class="title">Котёнок — ниндзя!</h2>
          <p class="desc" id="winText">Ты прошёл полосу!</p>
          <button id="restartBtn" class="main-btn" type="button">Играть снова</button>
        </div>
      </div>
    </div>

    <div class="controls" aria-label="Управление">
      <button class="control-btn" id="btnLeft" type="button">⬅ Влево</button>
      <button class="control-btn" id="btnRight" type="button">Вправо ➡</button>
      <button class="control-btn" id="btnJump" type="button">⤒ Прыжок</button>
      <button class="control-btn" id="btnDown" type="button">⬇ Вниз</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const livesEl = document.getElementById('lives');
    const checkpointEl = document.getElementById('checkpoint');
    const progressBar = document.getElementById('progressBar');
    const soundBtn = document.getElementById('soundBtn');
    const startOverlay = document.getElementById('startOverlay');
    const winOverlay = document.getElementById('winOverlay');
    const winText = document.getElementById('winText');

    const controls = {
      left: false,
      right: false,
      down: false,
      jumpHeld: false,
      jumpPressedAt: -Infinity,
    };

    const world = {
      width: 5600,
      finishX: 5480,
      gravity: 2200,
      cameraX: 0,
      time: 0,
    };

    const player = {
      x: 90,
      y: 460,
      w: 48,
      h: 54,
      vx: 0,
      vy: 0,
      speed: 420,
      jump: 860,
      onGround: false,
      groundY: Infinity,
      slideTimer: 0,
      jumpBufferMs: 130,
      coyoteMs: 110,
      lastGroundTime: 0,
      spawnX: 90,
      spawnY: 460,
      lives: 4,
      checkpointId: 0,
      facing: 1,
      hitFlash: 0,
      onPlatformId: null,
      standingOnMoving: null,
      friction: 0.86,
    };

    const checkpoints = [
      { id: 0, x: 90, label: 'Старт' },
      { id: 1, x: 1080, label: 'CP-1' },
      { id: 2, x: 2280, label: 'CP-2' },
      { id: 3, x: 3560, label: 'CP-3' },
      { id: 4, x: 4680, label: 'CP-4' },
    ];

    const level = {
      platforms: [
        { id: 'g0', x: 0, y: 560, w: 560, h: 160, type: 'ground' },
        { id: 'p1', x: 640, y: 520, w: 180, h: 30, type: 'static' },
        { id: 'p2', x: 860, y: 465, w: 130, h: 24, type: 'static' },
        { id: 'p3', x: 1020, y: 420, w: 100, h: 22, type: 'static' },
        { id: 'g1', x: 1180, y: 570, w: 420, h: 150, type: 'ground' },
        { id: 'mv1', x: 1670, y: 500, w: 150, h: 24, type: 'movingX', amp: 120, speed: 1.4 },
        { id: 'mv2', x: 1930, y: 455, w: 130, h: 22, type: 'movingY', amp: 72, speed: 1.9 },
        { id: 'bal1', x: 2140, y: 520, w: 220, h: 20, type: 'balance', amp: 20, speed: 2.8 },
        { id: 'g2', x: 2440, y: 575, w: 320, h: 145, type: 'ground' },
        { id: 'step1', x: 2790, y: 520, w: 70, h: 22, type: 'small' },
        { id: 'step2', x: 2900, y: 480, w: 65, h: 22, type: 'small' },
        { id: 'step3', x: 3010, y: 440, w: 62, h: 20, type: 'small' },
        { id: 'step4', x: 3120, y: 485, w: 70, h: 22, type: 'small' },
        { id: 'bounce1', x: 3245, y: 535, w: 120, h: 18, type: 'bounce' },
        { id: 'wallTop', x: 3465, y: 450, w: 220, h: 26, type: 'static' },
        { id: 'g3', x: 3340, y: 575, w: 560, h: 145, type: 'ground' },
        { id: 'ice1', x: 3920, y: 542, w: 280, h: 18, type: 'ice' },
        { id: 'van1', x: 4240, y: 520, w: 110, h: 20, type: 'vanish', period: 2.2, duty: 0.6 },
        { id: 'van2', x: 4390, y: 500, w: 110, h: 20, type: 'vanish', period: 2.2, duty: 0.55, phase: 0.55 },
        { id: 'lift1', x: 4580, y: 500, w: 120, h: 22, type: 'lift', amp: 100, speed: 1.5 },
        { id: 'g4', x: 4820, y: 575, w: 690, h: 145, type: 'ground' },
        { id: 'n1', x: 5070, y: 515, w: 84, h: 18, type: 'small' },
        { id: 'n2', x: 5200, y: 485, w: 84, h: 18, type: 'small' },
      ],
      hazards: [
        { x: 560, y: 580, w: 70, h: 140, kind: 'water' },
        { x: 1600, y: 590, w: 260, h: 130, kind: 'pit' },
        { x: 2368, y: 590, w: 74, h: 130, kind: 'pit' },
        { x: 2760, y: 590, w: 420, h: 130, kind: 'water' },
        { x: 4200, y: 595, w: 340, h: 125, kind: 'foam' },
      ],
      spinners: [
        { x: 1820, y: 430, len: 110, width: 12, speed: 2.7, phase: 0.3 },
        { x: 4950, y: 480, len: 120, width: 12, speed: 3.3, phase: 1.2 },
      ],
      pendulums: [
        { x: 2580, y: 300, len: 180, r: 28, amp: 0.9, speed: 2.0, phase: 0.2 },
        { x: 4730, y: 310, len: 165, r: 24, amp: 1.0, speed: 2.3, phase: 1.4 },
      ],
      lowBars: [
        { x: 3640, y: 500, w: 180, h: 18, gapY: 535 },
      ],
      narrowWalls: [
        { x: 5320, y: 430, w: 30, h: 145 },
        { x: 5390, y: 385, w: 30, h: 190 },
      ],
      signs: [
        { x: 5400, y: 540, text: 'Финиш!' },
      ],
    };

    const inputButtons = [
      ['btnLeft', 'left'],
      ['btnRight', 'right'],
      ['btnJump', 'jumpHeld'],
      ['btnDown', 'down'],
    ];

    let running = false;
    let won = false;
    let lastTime = performance.now();
    let soundEnabled = true;
    let audioCtx;

    function ensureAudio() {
      if (!audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return;
        audioCtx = new Ctx();
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function beep(type = 'sine', freq = 600, duration = 0.08, volume = 0.04) {
      if (!soundEnabled) return;
      ensureAudio();
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.start(now);
      osc.stop(now + duration);
    }

    function resetGame(full = true) {
      if (full) {
        player.lives = 4;
        player.checkpointId = 0;
      }
      const cp = checkpoints[player.checkpointId];
      player.x = cp.x;
      player.y = 430;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;
      player.slideTimer = 0;
      player.hitFlash = 0;
      world.cameraX = Math.max(0, Math.min(player.x - 260, world.width - canvas.width));
      updateHud();
    }

    function updateHud() {
      livesEl.textContent = String(player.lives);
      checkpointEl.textContent = checkpoints[player.checkpointId].label;
      const prog = Math.max(0, Math.min(100, (player.x / world.finishX) * 100));
      progressBar.style.width = `${prog.toFixed(1)}%`;
    }

    function hurt(reason = 'hit') {
      if (!running || won) return;
      player.lives -= 1;
      player.hitFlash = 0.34;
      beep('square', 180, 0.18, 0.06);
      if (player.lives <= 0) {
        player.lives = 1;
        player.checkpointId = Math.max(0, player.checkpointId - 1);
      }
      resetGame(false);
      if (reason === 'fall') beep('triangle', 130, 0.16, 0.05);
    }

    function currentPlatformRect(p, t) {
      let x = p.x;
      let y = p.y;
      let angle = 0;
      if (p.type === 'movingX') x += Math.sin(t * p.speed) * p.amp;
      if (p.type === 'movingY' || p.type === 'lift') y += Math.sin(t * p.speed) * p.amp;
      if (p.type === 'balance') {
        angle = Math.sin(t * p.speed) * 0.15;
        y += Math.sin(t * p.speed * 0.7) * p.amp;
      }
      const phase = p.phase || 0;
      const active = p.type !== 'vanish' || (((t + phase) % p.period) < p.period * p.duty);
      return { x, y, w: p.w, h: p.h, angle, active, id: p.id, type: p.type };
    }

    function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function segmentDistance(px, py, x1, y1, x2, y2) {
      const vx = x2 - x1;
      const vy = y2 - y1;
      const wx = px - x1;
      const wy = py - y1;
      const c1 = wx * vx + wy * vy;
      if (c1 <= 0) return Math.hypot(px - x1, py - y1);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return Math.hypot(px - x2, py - y2);
      const b = c1 / c2;
      const bx = x1 + b * vx;
      const by = y1 + b * vy;
      return Math.hypot(px - bx, py - by);
    }

    function update(dt) {
      world.time += dt;
      const nowMs = performance.now();

      const target = (controls.left ? -1 : 0) + (controls.right ? 1 : 0);
      if (target !== 0) player.facing = target;

      const accel = player.onGround ? 2800 : 1700;
      const maxSpeed = controls.down ? 250 : player.speed;
      player.vx += target * accel * dt;
      if (target === 0) player.vx *= player.friction;
      player.vx = Math.max(-maxSpeed, Math.min(maxSpeed, player.vx));

      if (controls.down && player.onGround) player.slideTimer = Math.max(player.slideTimer, 0.2);
      if (player.slideTimer > 0) player.slideTimer -= dt;
      const h = player.slideTimer > 0 ? 36 : player.h;

      if (controls.jumpPressedAt + player.jumpBufferMs > nowMs) {
        const canJump = player.onGround || (nowMs - player.lastGroundTime < player.coyoteMs);
        if (canJump) {
          player.vy = -player.jump;
          player.onGround = false;
          controls.jumpPressedAt = -Infinity;
          beep('triangle', 620, 0.09, 0.05);
        }
      }

      player.vy += world.gravity * dt;
      const prevX = player.x;
      const prevY = player.y;
      player.x += player.vx * dt;

      const platformRects = level.platforms.map((p) => currentPlatformRect(p, world.time));

      // horizontal collision
      for (const p of platformRects) {
        if (!p.active) continue;
        if (aabb(player.x, player.y + (player.h - h), player.w, h, p.x, p.y, p.w, p.h)) {
          if (player.vx > 0) player.x = p.x - player.w;
          if (player.vx < 0) player.x = p.x + p.w;
          player.vx = 0;
        }
      }

      player.y += player.vy * dt;
      player.onGround = false;
      player.standingOnMoving = null;

      for (const p of platformRects) {
        if (!p.active) continue;
        const px = player.x;
        const py = player.y + (player.h - h);
        if (aabb(px, py, player.w, h, p.x, p.y, p.w, p.h)) {
          const fromAbove = prevY + (player.h - h) <= p.y + 4 && player.vy >= 0;
          if (fromAbove) {
            player.y = p.y - h - (player.h - h);
            player.vy = 0;
            player.onGround = true;
            player.lastGroundTime = performance.now();
            player.onPlatformId = p.id;
            if (p.type === 'movingX' || p.type === 'movingY' || p.type === 'lift') {
              player.standingOnMoving = p;
            }
            if (p.type === 'bounce') {
              player.vy = -1120;
              player.onGround = false;
              beep('sawtooth', 730, 0.07, 0.06);
            }
            if (p.type === 'ice') {
              player.friction = 0.965;
            } else {
              player.friction = 0.86;
            }
          } else {
            if (player.vy < 0) {
              player.y = p.y + p.h - (player.h - h);
              player.vy = 60;
            }
          }
        }
      }

      if (!player.onGround) {
        player.friction = 0.86;
      }

      if (player.standingOnMoving) {
        const p = level.platforms.find((x) => x.id === player.standingOnMoving.id);
        if (p?.type === 'movingX') {
          const delta = Math.cos(world.time * p.speed) * p.amp * p.speed * dt;
          player.x += delta;
        }
      }

      // drop through temporary small platforms
      if (controls.down && player.onGround) {
        const p = level.platforms.find((x) => x.id === player.onPlatformId);
        if (p && ['small', 'vanish'].includes(p.type)) {
          player.y += 4;
          player.onGround = false;
        }
      }

      // hazards
      for (const hz of level.hazards) {
        if (aabb(player.x + 8, player.y + 8, player.w - 16, h - 8, hz.x, hz.y, hz.w, hz.h)) {
          hurt('fall');
          return;
        }
      }

      // spinner hit
      for (const s of level.spinners) {
        const angle = world.time * s.speed + s.phase;
        const x1 = s.x;
        const y1 = s.y;
        const x2 = s.x + Math.cos(angle) * s.len;
        const y2 = s.y + Math.sin(angle) * s.len;
        const d = segmentDistance(player.x + player.w / 2, player.y + h / 2, x1, y1, x2, y2);
        if (d < 24) {
          hurt('hit');
          return;
        }
      }

      for (const p of level.pendulums) {
        const a = Math.sin(world.time * p.speed + p.phase) * p.amp;
        const bx = p.x + Math.sin(a) * p.len;
        const by = p.y + Math.cos(a) * p.len;
        const d = Math.hypot(player.x + player.w / 2 - bx, player.y + h / 2 - by);
        if (d < p.r + 18) {
          hurt('hit');
          return;
        }
      }

      // low bars (need slide)
      for (const bar of level.lowBars) {
        if (aabb(player.x, player.y + (player.h - h), player.w, h, bar.x, bar.y, bar.w, bar.h)) {
          if (player.slideTimer <= 0) {
            hurt('hit');
            return;
          }
        }
      }

      // narrow walls
      for (const nw of level.narrowWalls) {
        if (aabb(player.x, player.y + (player.h - h), player.w, h, nw.x, nw.y, nw.w, nw.h)) {
          if (player.vx > 0) player.x = nw.x - player.w;
          if (player.vx < 0) player.x = nw.x + nw.w;
          player.vx = 0;
        }
      }

      player.x = Math.max(0, Math.min(world.width - player.w, player.x));
      if (player.y > 760) {
        hurt('fall');
        return;
      }

      // checkpoint updates
      for (const cp of checkpoints) {
        if (player.x >= cp.x && cp.id > player.checkpointId) {
          player.checkpointId = cp.id;
          beep('sine', 900, 0.05, 0.04);
        }
      }

      if (player.x > world.finishX) {
        won = true;
        running = false;
        winText.textContent = `Финиш достигнут! Осталось жизней: ${player.lives}.`; 
        winOverlay.hidden = false;
        beep('triangle', 880, 0.1, 0.05);
        setTimeout(() => beep('triangle', 1170, 0.18, 0.05), 90);
      }

      world.cameraX += ((player.x - canvas.width * 0.35) - world.cameraX) * Math.min(1, 6 * dt);
      world.cameraX = Math.max(0, Math.min(world.width - canvas.width, world.cameraX));
      if (player.hitFlash > 0) player.hitFlash -= dt;
      updateHud();
    }

    function drawBackground() {
      const cam = world.cameraX;
      const t = world.time;
      const mountainBase = 420;

      ctx.fillStyle = '#9de4ff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // clouds
      for (let i = 0; i < 8; i += 1) {
        const x = ((i * 260 - cam * 0.18 + t * 20) % (canvas.width + 320)) - 160;
        const y = 70 + (i % 3) * 40;
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.beginPath();
        ctx.ellipse(x, y, 48, 22, 0, 0, Math.PI * 2);
        ctx.ellipse(x + 30, y + 6, 36, 18, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#7aa0f0';
      for (let i = 0; i < 12; i += 1) {
        const x = i * 220 - (cam * 0.35 % 220);
        ctx.beginPath();
        ctx.moveTo(x, mountainBase);
        ctx.lineTo(x + 110, mountainBase - 120 - (i % 2) * 50);
        ctx.lineTo(x + 220, mountainBase);
        ctx.closePath();
        ctx.fill();
      }

      ctx.fillStyle = '#6cb56a';
      ctx.fillRect(0, 560, canvas.width, 160);
    }

    function drawPlatform(p) {
      if (!p.active) return;
      const x = p.x - world.cameraX;
      const y = p.y;
      ctx.save();
      if (p.angle) {
        ctx.translate(x + p.w / 2, y + p.h / 2);
        ctx.rotate(p.angle);
        ctx.translate(-p.w / 2, -p.h / 2);
      } else {
        ctx.translate(x, y);
      }

      let fill = '#ffe9a6';
      if (p.type === 'ground') fill = '#8fd07d';
      if (p.type === 'movingX' || p.type === 'movingY' || p.type === 'lift') fill = '#8de0ff';
      if (p.type === 'bounce') fill = '#ff97b3';
      if (p.type === 'ice') fill = '#b8f4ff';
      if (p.type === 'vanish') fill = '#ffd89d';
      if (p.type === 'small') fill = '#fff1c8';

      ctx.fillStyle = fill;
      ctx.strokeStyle = '#2b406f';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(0, 0, p.w, p.h, 8);
      ctx.fill();
      ctx.stroke();

      if (p.type === 'bounce') {
        ctx.strokeStyle = '#c42d68';
        ctx.beginPath();
        ctx.moveTo(14, p.h - 3);
        ctx.lineTo(p.w - 14, p.h - 3);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawPlayer() {
      const isSlide = player.slideTimer > 0;
      const h = isSlide ? 36 : player.h;
      const x = player.x - world.cameraX;
      const y = player.y + (player.h - h);

      ctx.save();
      if (player.hitFlash > 0 && Math.floor(world.time * 40) % 2 === 0) {
        ctx.globalAlpha = 0.45;
      }

      ctx.translate(x + player.w / 2, y + h / 2);
      ctx.scale(player.facing, 1);

      // body
      ctx.fillStyle = '#ffd66f';
      ctx.strokeStyle = '#304370';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(-20, -16, 40, 28, 10);
      ctx.fill();
      ctx.stroke();

      // head
      ctx.beginPath();
      ctx.roundRect(-18, -34, 36, 24, 12);
      ctx.fill();
      ctx.stroke();

      // ears
      ctx.beginPath();
      ctx.moveTo(-14, -34);
      ctx.lineTo(-9, -49);
      ctx.lineTo(-2, -34);
      ctx.moveTo(14, -34);
      ctx.lineTo(9, -49);
      ctx.lineTo(2, -34);
      ctx.stroke();

      ctx.fillStyle = '#ff8ab7';
      ctx.beginPath();
      ctx.arc(-8, -20, 3, 0, Math.PI * 2);
      ctx.arc(8, -20, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#1b315d';
      ctx.beginPath();
      ctx.arc(-6, -23, 2.2, 0, Math.PI * 2);
      ctx.arc(6, -23, 2.2, 0, Math.PI * 2);
      ctx.fill();

      // tail
      ctx.strokeStyle = '#304370';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(-20, -7);
      ctx.quadraticCurveTo(-34, -14, -28, -24 + Math.sin(world.time * 12) * 3);
      ctx.stroke();

      ctx.restore();
    }

    function drawObstacles() {
      for (const hz of level.hazards) {
        const x = hz.x - world.cameraX;
        if (x > canvas.width || x + hz.w < -30) continue;
        ctx.fillStyle = hz.kind === 'water' ? '#58c7ff' : hz.kind === 'foam' ? '#d294ff' : '#5476b3';
        ctx.fillRect(x, hz.y, hz.w, hz.h);
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < hz.w; i += 30) {
          ctx.moveTo(x + i, hz.y + 8 + Math.sin(world.time * 4 + i) * 3);
          ctx.lineTo(x + i + 14, hz.y + 12 + Math.sin(world.time * 4 + i) * 3);
        }
        ctx.stroke();
      }

      for (const s of level.spinners) {
        const angle = world.time * s.speed + s.phase;
        const cx = s.x - world.cameraX;
        const cy = s.y;
        const ex = cx + Math.cos(angle) * s.len;
        const ey = cy + Math.sin(angle) * s.len;
        ctx.strokeStyle = '#e25075';
        ctx.lineWidth = s.width;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(ex, ey);
        ctx.stroke();
        ctx.fillStyle = '#ffe6b1';
        ctx.beginPath();
        ctx.arc(cx, cy, 12, 0, Math.PI * 2);
        ctx.fill();
      }

      for (const p of level.pendulums) {
        const a = Math.sin(world.time * p.speed + p.phase) * p.amp;
        const cx = p.x - world.cameraX;
        const bx = cx + Math.sin(a) * p.len;
        const by = p.y + Math.cos(a) * p.len;
        ctx.strokeStyle = '#2d4476';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(cx, p.y);
        ctx.lineTo(bx, by);
        ctx.stroke();
        ctx.fillStyle = '#ff6f9d';
        ctx.beginPath();
        ctx.arc(bx, by, p.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }

      for (const bar of level.lowBars) {
        const x = bar.x - world.cameraX;
        ctx.fillStyle = '#7a4fb4';
        ctx.fillRect(x, bar.y, bar.w, bar.h);
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.fillRect(x + 6, bar.y + 2, bar.w - 12, 4);
      }

      for (const nw of level.narrowWalls) {
        const x = nw.x - world.cameraX;
        ctx.fillStyle = '#6a4ea7';
        ctx.fillRect(x, nw.y, nw.w, nw.h);
      }

      for (const sign of level.signs) {
        const x = sign.x - world.cameraX;
        ctx.fillStyle = '#fff1b8';
        ctx.fillRect(x, sign.y - 40, 100, 32);
        ctx.strokeStyle = '#3e4f80';
        ctx.strokeRect(x, sign.y - 40, 100, 32);
        ctx.fillStyle = '#1f3766';
        ctx.font = 'bold 18px Trebuchet MS';
        ctx.fillText(sign.text, x + 10, sign.y - 18);
      }
    }

    function drawCheckpoints() {
      for (const cp of checkpoints) {
        const x = cp.x - world.cameraX;
        if (x < -40 || x > canvas.width + 40) continue;
        ctx.strokeStyle = cp.id <= player.checkpointId ? '#2bd37d' : '#ffde66';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(x, 560);
        ctx.lineTo(x, 470);
        ctx.stroke();
        ctx.fillStyle = cp.id <= player.checkpointId ? '#76ffb0' : '#ffeb95';
        ctx.beginPath();
        ctx.moveTo(x, 470);
        ctx.lineTo(x + 26, 482);
        ctx.lineTo(x, 494);
        ctx.closePath();
        ctx.fill();
      }
    }

    function draw() {
      drawBackground();
      drawCheckpoints();
      const platformRects = level.platforms.map((p) => currentPlatformRect(p, world.time));
      for (const p of platformRects) {
        const sx = p.x - world.cameraX;
        if (sx > canvas.width + 80 || sx + p.w < -80) continue;
        drawPlatform(p);
      }
      drawObstacles();
      drawPlayer();
    }

    function gameLoop(ts) {
      const dt = Math.min(0.033, (ts - lastTime) / 1000);
      lastTime = ts;
      if (running) update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    function setPressed(action, pressed, pressEvent = false) {
      controls[action] = pressed;
      if (action === 'jumpHeld' && pressEvent) {
        controls.jumpPressedAt = performance.now();
      }
    }

    function setupControls() {
      document.addEventListener('keydown', (e) => {
        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Space'].includes(e.code)) e.preventDefault();
        if (e.code === 'ArrowLeft') setPressed('left', true);
        if (e.code === 'ArrowRight') setPressed('right', true);
        if (e.code === 'ArrowDown') setPressed('down', true);
        if (e.code === 'ArrowUp' || e.code === 'Space') setPressed('jumpHeld', true, true);
      });

      document.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowLeft') setPressed('left', false);
        if (e.code === 'ArrowRight') setPressed('right', false);
        if (e.code === 'ArrowDown') setPressed('down', false);
        if (e.code === 'ArrowUp' || e.code === 'Space') setPressed('jumpHeld', false);
      });

      for (const [id, action] of inputButtons) {
        const btn = document.getElementById(id);
        const begin = (ev) => {
          ev.preventDefault();
          btn.classList.add('active');
          const pressEvent = action === 'jumpHeld';
          setPressed(action, true, pressEvent);
          beep('sine', 520, 0.03, 0.03);
        };
        const end = (ev) => {
          ev.preventDefault();
          btn.classList.remove('active');
          setPressed(action, false);
        };
        btn.addEventListener('pointerdown', begin);
        btn.addEventListener('pointerup', end);
        btn.addEventListener('pointercancel', end);
        btn.addEventListener('pointerleave', (ev) => {
          if (ev.buttons === 1) end(ev);
        });
      }
    }

    function start() {
      ensureAudio();
      running = true;
      won = false;
      startOverlay.hidden = true;
      winOverlay.hidden = true;
      resetGame(true);
      beep('triangle', 700, 0.06, 0.05);
    }

    document.getElementById('startBtn').addEventListener('click', start);
    document.getElementById('restartBtn').addEventListener('click', start);
    soundBtn.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundBtn.textContent = `Звук: ${soundEnabled ? 'вкл' : 'выкл'}`;
      if (soundEnabled) beep('sine', 820, 0.04, 0.03);
    });

    setupControls();
    resetGame(true);
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
